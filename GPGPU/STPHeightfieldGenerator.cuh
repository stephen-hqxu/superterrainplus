#pragma once
#ifndef _STP_HEIGHTFIELD_GENERATOR_CUH_
#define _STP_HEIGHTFIELD_GENERATOR_CUH_

//CUDA
//CUDA lib are included in the "Engine" section
#include <curand_kernel.h>
//Engine
#include "STPSimplexNoise.cuh"
#include "STPRainDrop.cuh"
//Settings
#include "../Settings/STPHeightfieldSettings.hpp"

/**
 * @brief Super Terrain + is an open source, procedural terrain engine running on OpenGL 4.6, which utilises most modern terrain rendering techniques
 * including perlin noise generated height map, hydrology processing and marching cube algorithm.
 * Super Terrain + uses GLFW library for display and GLAD for opengl contexting.
*/
namespace SuperTerrainPlus {
	/**
	 * @brief GPGPU compute suites for Super Terrain + program, powered by CUDA
	*/
	namespace STPCompute {
		
		/**
		 * @brief Generate the terriain height map, the height map will be then used to
		 * represent the offset in y direction of the terrain. Heightfield is generated by 2D simplex noise.
		*/
		class STPHeightfieldGenerator {
		public:

			//TODO You can change your preferred RNG here!
			//Choosen generator for curand
			typedef curandStatePhilox4_32_10 curandRNG;

		private:

			//Launch parameter for texture
			dim3 numThreadperBlock_Map, numBlock_Map;
			//Launch parameter for hydraulic erosion
			int numThreadperBlock_Erosion, numBlock_Erosion;

			/**
			 * @brief Simplex noise generator, on device
			*/
			STPSimplexNoise* simplex = nullptr;
			//All parameters required for the heightfield generator, stored on deivce
			STPSettings::STPHeightfieldSettings* Settings = nullptr;
			//All parameters for the noise generator, stoed on host, passing value to device
			STPSettings::STPSimplexNoiseSettings* Noise_Settings = nullptr;

			//curand random number generator for erosion, each generator will be dedicated for one thread, i.e., thread independency
			curandRNG* RNG_Map = nullptr;
			//Determine the number of raindrop to summon, the higher the more accurate but slower
			//Each time this value changes, the rng needs to be re-sampled
			int NumRaindrop = 0;

		public:

			/**
			 * @brief Init the heightfield generator
			 * @param settings Stored all parameters for the heightmap calculation launch, it will be deep copied to the class so dynamic memory is not required
			 * @param noise_settings Stored all parameters for the heightmap random number generator, it will be deep copied to the class so dynamic memory is not required
			*/
			__host__ STPHeightfieldGenerator(STPSettings::STPHeightfieldSettings* const, const STPSettings::STPSimplexNoiseSettings* const);

			__host__ ~STPHeightfieldGenerator();

			/**
			 * @brief Generate the terrain heightfield maps, each heightfield contains four maps, being heightmap and normalmap.
			 * All storage spaces must be preallocated with width * height * sizeof(float), with the exception of normalmap, which requires width * height * sizeof(float) * 4.
			 * The function will first generate our epic height map using simplex noise function, using the parameter provided during class init.
			 * The generated heightmap will be in range [0,1]
			 * Then performing hydraulic erosion algorithm to erode the rough terrain into a more natrual form.
			 * The number of iteration must be set via setErosionIterationCUDA() so pre-computation can be done before launching the program.
			 * Lastly it will generate the normal map for the height map, the normalmap is normalised within the range [0,1].
			 * All four maps are kept in floating point pixel format.
			 * @param heightmap A float array that will be used to stored heightmap pixles, must be pre-allocated with at least width * height * sizeof(float), i.e., R32F format
			 * @param normalmap A float array that will be used to stored normnalmap pixles, will be used to store the output of the normal map, must be
			 * pre allocated with at least width * height * 4 byte per channel * 4, i.e., RGBA32F format.
			 * @param offset The x vector specify the offset on x direction of the map and and z on y direction of the map, and the y vector specify the offset on the final result.
			 * The offset parameter will only be applied on the heightmap generation.
			 * @return True if all operation are successful without any errors
			*/
			__host__ bool generateHeightfieldCUDA(float*, float*, float3 = make_float3(0.0f, 0.0f, 0.0f));

			/**
			 * @brief Set the number of raindrop to spawn for each hydraulic erosion run, each time the function is called some recalculation needs to be re-done.
			 * Determine the number of raindrop to summon, the higher the more accurate but slower
			 * @param raindrop_count The number of raindrop (number ofc iteration) for the erosion algorithm
			 * @return True if successsfully updated the count and no error was generated during calculation
			*/
			__host__ bool setErosionIterationCUDA(unsigned int);

			/**
			 * @brief Get the number of iteration for hydraulic erosion
			 * @return The number of raindrop to erode the terrain
			*/
			__host__ int getErosionIteration();

			/**
			 * @brief Set the heightfield parameter, the current parameter set will be replaced, the input will be copied to device
			 * @param settings - The input settings stored on host, it will be copied to device
			 * @return True if the new parameters have been set
			*/
			__host__ bool setHeightfieldParameter(const STPSettings::STPHeightfieldSettings&);

			/**
			 * @brief Get the current parameter stored in the class, it will be copied from device
			 * @return The current parameter set on host, needs to be freed with freeHeightfieldGenerator()
			*/
			__host__ SuperTerrainPlus::STPSettings::STPHeightfieldSettings* getHeightfieldParameter();

			/**
			 * @brief Free the returning host parameter returned from getHeightfieldGenerator()
			 * @param memory The returned memory that needs to be freed.
			*/
			__host__ void freeHeightfieldParameter(STPSettings::STPHeightfieldSettings* const);

		};

		/**
		 * @brief Kernel launch and util functions
		*/
		namespace STPKernelLauncher{

			/**
			 * @brief Find the unit vector of the input vector
			 * @param vec3 - Vector input 
			 * @return Unit vector of the input
			*/
			__device__ float3 normalize3DKERNEL(float3);

			/**
			 * @brief Performing inverse linear interpolation for each value on the heightmap to scale it within [0,1] using CUDA kernel
			 * @param minVal The mininmum value that can apperar in this height map
			 * @param maxVal The maximum value that can apperar in this height map
			 * @param value The input value
			 * @return The interpolated value
			*/
			__device__ float InvlerpKERNEL(float, float, float);

			/**
			 * @brief Clamp the input value with the range
			 * @param val The clamping value
			 * @param lower The lowest possible value
			 * @param upper The highest possible value
			 * @return val if [lower, upper], lower if val < lower, upper if val > upper
			*/
			__device__ int clamp(int, int, int);

			/**
			 * @brief Init the curand generator for each thread
			 * @param rng The random number generator array, it must have the same number of element as thread. e.g., 
			 * generating x random number each in 1024 thread needs 1024 rng, each thread will use the same sequence.
			 * @param seed The seed for each generator
			*/
			__global__ void curandInitKERNEL(STPHeightfieldGenerator::curandRNG*, unsigned long long);

			/**
			 * @brief Generate our epic height map using simplex noise function within the CUDA kernel
			 * @param noise_fun - The heightfield generator that's going to use
			 * @param height_storage - The pointer to a location where the heightmap will be stored
			 * @param dimension - The width and height of the generated heightmap
			 * @param half_dimension - Precomputed dimension/2 so the kernel don't need to repeatly compute that
			 * @param settings - The parameter set for the heightfield generator
			 * @param offset - Controlling the offset on x, y and height offset on z
			*/
			__global__ void generateHeightmapKERNEL(STPSimplexNoise* const, float*, uint2, float2, STPSettings::STPHeightfieldSettings* const, float3);

			/**
			 * @brief Performing hydraulic erosion for the given heightmap terrain using CUDA parallel computing
			 * @param height_storage Heightmap that is going to erode with raindrop
			 * @param dimension The size of all maps, they must be the same
			 * @param rng The random number generator map sequence, independent for each rain drop
			 * @param settings The parameter set for each rain drop
			*/
			__global__ void performErosionKERNEL(float*, uint2, STPHeightfieldGenerator::curandRNG*, STPSettings::STPRainDropSettings* const);

			/**
			* @brief Generate the normal map for the height map within kernel
			* @param noise_fun - The heightfield generator that's going to use
			* @param heightmap - contains the height map that will be wused to generate the normal
			* @param normal_storage - normal map, will be used to store the output of the normal map
			* @param dimension - The width and height of both map
			* @param settings - The parameter set for the heightfield generator
			* @return True if the normal map is successully generated without errors
			*/
			__global__ void generateNormalmapKERNEL(STPSimplexNoise* const, float* const, float*, uint2, STPSettings::STPHeightfieldSettings* const);

		}

	}
}
#endif//_STP_HEIGHTFIELD_GENERATOR_CUH_