#pragma once
#ifndef _STP_HEIGHTFIELD_GENERATOR_CUH_
#define _STP_HEIGHTFIELD_GENERATOR_CUH_

//System
#include <mutex>
#include <list>
//CUDA
//CUDA lib are included in the "Engine" section
#include <curand_kernel.h>
//Engine
#include "STPSimplexNoise.cuh"
#include "STPRainDrop.cuh"
#include "../World/Biome/STPBiome.h"
#include "../Helpers/STPMemoryPool.hpp"
//Settings
#include "../Settings/STPHeightfieldSettings.hpp"
#include "../Settings/STPChunkSettings.hpp"

/**
 * @brief Super Terrain + is an open source, procedural terrain engine running on OpenGL 4.6, which utilises most modern terrain rendering techniques
 * including perlin noise generated height map, hydrology processing and marching cube algorithm.
 * Super Terrain + uses GLFW library for display and GLAD for opengl contexting.
*/
namespace SuperTerrainPlus {
	/**
	 * @brief GPGPU compute suites for Super Terrain + program, powered by CUDA
	*/
	namespace STPCompute {
		
		/**
		 * @brief Generate the terriain height map, the height map will be then used to
		 * represent the offset in y direction of the terrain. Heightfield is generated by 2D simplex noise.
		*/
		class STPHeightfieldGenerator {
		public:

			//STPGeneratorOperation controls the operations to perform during heightfield generation
			typedef unsigned short STPGeneratorOperation;
			//STPFormatGuide provides instruction to the formatter that which map should be formatted
			typedef unsigned short STPFormatGuide;

			//TODO You can change your preferred RNG here!
			//Choosen generator for curand
			typedef curandStatePhilox4_32_10 curandRNG;

			//A function that converts biome id to the index corresponded in biome table
			//By default it's a 1-1 mapping, meaning biome id = index
			typedef size_t(*STPBiomeInterpreter)(STPBiome::Sample);

			//Generate a new heightmap with simplex noise and store the result in the provided memory space
			constexpr static STPGeneratorOperation HeightmapGeneration = 1u << 0u;
			//Erode the heightmap. If HeightmapGeneration flag is not enabled, an available heightmap needs to be provided for the operation
			constexpr static STPGeneratorOperation Erosion = 1u << 1u;
			//Generate normal map. If HeightmapGeneration flag is not enabled, an available heightmap needs to be provided for the operation
			constexpr static STPGeneratorOperation NormalmapGeneration = 1u << 2u;
			//Format the map from FP32 to INT16. Providing FormatHint flag in STPMapStorage to specify which map to format.
			constexpr static STPGeneratorOperation Format = 1u << 3u;
			//Enable format of heightmap, Format flag needs to be set to enable
			constexpr static STPFormatGuide FormatHeightmap = 1u << 0u;
			//Enable format of normalmap, Format flag needs to be set to enable
			constexpr static STPFormatGuide FormatNormalmap = 1u << 1u;

			/**
			 * @brief STPMapStorage stores heightfield data for the generator
			*/
			struct STPMapStorage {
			public:

				//- A float array that will be used to stored heightmap pixles, must be pre-allocated with at least width * height * sizeof(float), i.e., R32F format
				//- If generator is instructed to generate only a single heightmap, only one map is required
				//- If hydraulic erosion and/or normalmap generation is enabled, a list of maps of neighbour chunks are required for edge sync, heightmap generation will 
				//only affect the central chunk, for neighbour chunks it must be precomputed with heightmap to be able to perform free-slip hydraulic erosion,
				//If free-slip hydraulic erosion is disabled, no neighbour chunks are required.
				//- The map pointers should be arranged in row major matrix, with defined neighbour dimension.
				std::list<float*> Heightmap32F;
				//The x vector specify the offset on x direction of the map and and z on y direction of the map, and the y vector specify the offset on the final result.
				//The offset parameter will only be applied on the heightmap generation.
				float3 HeightmapOffset = make_float3(0.0f, 0.0f, 0.0f);
				//A float array that will be used to stored normnalmap pixles, will be used to store the output of the normal map.
				//Must be pre-allocated with at least width* height * 4 byte per channel * 4, i.e., RGBA32F format.
				float* Normalmap32F = nullptr;
				//Instruct formatter that which map to format.
				//If Format flag is not set for the generator, format operation will not happen regardlessly
				STPFormatGuide FormatHint;
				//A INT16 array that will be used to stored the heightmap after formation. Require Format flag set in the generator and FormatHeightmap set in FormatHint 
				unsigned short* Heightmap16UI = nullptr;
				//A INT16 array that will be used to stored the normalmap after formation. Require Format flag set in the generator and FormatHeightmap set in FormatHint
				//Require either normalmap generation enabled or provided from the external
				unsigned short* Normalmap16UI = nullptr;

			};

		private:

			/**
			 * @brief Memory allocation of tempoary computing cache for heightfield generator
			*/
			class STPHeightfieldAllocator {
			public:

				/**
				 * @brief Allocate memory on GPU
				 * @param count The number of byte of float
				 * @return The device pointer
				*/
				__host__ float* allocate(size_t);

				/**
				 * @brief Free up the GPU memory
				 * @param count The number float to free
				 * @param The device pointer to free
				*/
				__host__ void deallocate(size_t, float*);

			};

			/**
			 * @brief Allocate memory for image converter output
			*/
			class STPImageConverterAllocator {
			public:

				/**
				 * @brief Allocate memory on GPU
				 * @param count The number of byte of unsigned int
				 * @return The device pointer
				*/
				__host__ unsigned short* allocate(size_t);

				/**
				 * @brief Free up the GPU memory
				 * @param count The number unsigned int to free
				 * @param The device pointer to free
				*/
				__host__ void deallocate(size_t, unsigned short*);

			};

			/**
			 * @brief Memory allocation for pinned memory
			*/
			class STPHeightfieldHostAllocator {
			public:

				/**
				 * @brief Allocate page-locked memory on host
				 * @param count The number of byte of float
				 * @return The memory pointer
				*/
				__host__ float* allocate(size_t);

				/**
				 * @brief Free up the host pinned memory
				 * @param count The number unsigned int to free
				 * @param The hsot pinned pointer to free
				*/
				__host__ void deallocate(size_t, float*);

			};

			//Launch parameter for texture
			dim3 numThreadperBlock_Map, numBlock_Map;
			//Launch parameter for hydraulic erosion
			int numThreadperBlock_Erosion, numBlock_Erosion;

			/**
			 * @brief Simplex noise generator, on device
			*/
			STPSimplexNoise* simplex = nullptr;
			const STPSimplexNoise simplex_h;
			//All parameters for the noise generator, stoed on host, passing value to device
			const STPSettings::STPSimplexNoiseSettings Noise_Settings;

			//curand random number generator for erosion, each generator will be dedicated for one thread, i.e., thread independency
			curandRNG* RNG_Map = nullptr;
			/**
			 * @brief Convert global index to global index, making data access outside the central chunk available
			 * As shown the difference between local and global index
			 *		 Local					 Global
			 * 0 1 2 3 | 0 1 2 3	0  1  2  3  | 4  5  6  7
			 * 4 5 6 7 | 4 5 6 7	8  9  10 11 | 12 13 14 15
			 * -----------------	-------------------------
			 * 0 1 2 3 | 0 1 2 3	16 17 18 19 | 20 21 22 23
			 * 4 5 6 7 | 4 5 6 7	24 25 26 27 | 28 29 30 21
			 *
			 * Given that chunk should be arranged in a linear array (just an example)
			 * Chunk 1 | Chunk 2
			 * -----------------
			 * Chunk 3 | Chunk 4
			*/
			unsigned int* GlobalLocalIndex = nullptr;
			//Free slip range in the unit of chunk
			const uint2 FreeSlipChunk;
			//Determine the number of raindrop to summon, the higher the more accurate but slower
			//Each time this value changes, the rng needs to be re-sampled
			unsigned int NumRaindrop = 0u;

			STPBiome::STPBiome* BiomeDictionary = nullptr;

			//Temp cache on device for heightmap computation
			mutable std::mutex MapCache32F_lock;
			mutable std::mutex MapCache16UI_lock;
			mutable std::mutex MapCachePinned_lock;
			mutable STPMemoryPool<float, STPHeightfieldAllocator> MapCache32F_device;
			mutable STPMemoryPool<unsigned short, STPImageConverterAllocator> MapCache16UI_device;
			mutable STPMemoryPool<float, STPHeightfieldHostAllocator> MapCachePinned;

			/**
			 * @brief Generate the local global index lookup table
			 * @return True if generation is successful without errors
			*/
			__host__ bool setLocalGlobalIndexCUDA();

		public:

			/**
			 * @brief Init the heightfield generator
			 * @param noise_settings Stored all parameters for the heightmap random number generator, it will be deep copied to the class so dynamic memory is not required
			 * @param chunk_settings Stored all parameters for the chunk
			*/
			__host__ STPHeightfieldGenerator(const STPSettings::STPSimplexNoiseSettings*, const STPSettings::STPChunkSettings*);

			__host__ ~STPHeightfieldGenerator();

			__host__ STPHeightfieldGenerator(const STPHeightfieldGenerator&) = delete;

			__host__ STPHeightfieldGenerator(STPHeightfieldGenerator&&) = delete;

			__host__ STPHeightfieldGenerator& operator=(const STPHeightfieldGenerator&) = delete;

			__host__ STPHeightfieldGenerator& operator=(STPHeightfieldGenerator&&) = delete;

			/**
			 * @brief Load the settings for heightfield generator, all subsequent computation will base on this settings. Settings are copied.
			 * It needs to be called before launching any compute
			 * @param settings The parameters of the generation algorithm. It should be on host side.
			 * @return True if setting can be used
			*/
			__host__ static bool useSettings(const STPSettings::STPHeightfieldSettings* const);

			/**
			 * @brief Define the biome dictionary for looking up biome settins according to the biome id. Each entry of biome will be copied to device
			 * @tparam Ite The iterator to the original container with all biomes
			 * @param begin The beginning of the container with biomes
			 * @param end The end of the container with biomes
			 * @return True if copy was successful
			*/
			template<typename Ite>
			__host__ bool defineDictionary(Ite, Ite);

			/**
			 * @brief Generate the terrain heightfield maps, each heightfield contains four maps, being heightmap and normalmap.
			 * All storage spaces must be preallocated with width * height * sizeof(float), with the exception of normalmap, which requires width * height * sizeof(float) * 4.
			 * The function will first generate our epic height map using simplex noise function, using the parameter provided during class init.
			 * The generated heightmap will be in range [0,1]
			 * Then performing hydraulic erosion algorithm to erode the rough terrain into a more natrual form.
			 * The number of iteration must be set via setErosionIterationCUDA() so pre-computation can be done before launching the program.
			 * Lastly it will generate the normal map for the height map, the normalmap is normalised within the range [0,1].
			 * All four maps are kept in floating point pixel format.
			 * @param args The generator data, see STPMapStorage documentation for more details
			 * @param operation Control what type of operation generator does
			 * @return True if all operation are successful without any errors
			*/
			__host__ bool generateHeightfieldCUDA(STPMapStorage&, STPGeneratorOperation) const;

			/**
			 * @brief Set the number of raindrop to spawn for each hydraulic erosion run, each time the function is called some recalculation needs to be re-done.
			 * Determine the number of raindrop to summon, the higher the more accurate but slower
			 * @param raindrop_count The number of raindrop (number ofc iteration) for the erosion algorithm
			 * @return True if successsfully updated the count and no error was generated during calculation
			*/
			__host__ bool setErosionIterationCUDA(unsigned int);

			/**
			 * @brief Get the number of iteration for hydraulic erosion
			 * @return The number of raindrop to erode the terrain
			*/
			__host__ unsigned int getErosionIteration() const;

		};

	}
}
#include "STPHeightfieldGenerator.inl"
#endif//_STP_HEIGHTFIELD_GENERATOR_CUH_