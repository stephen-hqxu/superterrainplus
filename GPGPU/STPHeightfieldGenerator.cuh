#pragma once
#ifndef _STP_HEIGHTFIELD_GENERATOR_CUH_
#define _STP_HEIGHTFIELD_GENERATOR_CUH_

//System
#include <mutex>
#include <list>
//CUDA
//CUDA lib are included in the "Engine" section
#include <curand_kernel.h>
//Engine
#include "STPSimplexNoise.cuh"
#include "STPRainDrop.cuh"
#include "../World/Biome/STPBiome.h"
#include "../Helpers/STPMemoryPool.hpp"
//Settings
#include "../Settings/STPHeightfieldSettings.hpp"
#include "../Settings/STPChunkSettings.hpp"

/**
 * @brief Super Terrain + is an open source, procedural terrain engine running on OpenGL 4.6, which utilises most modern terrain rendering techniques
 * including perlin noise generated height map, hydrology processing and marching cube algorithm.
 * Super Terrain + uses GLFW library for display and GLAD for opengl contexting.
*/
namespace SuperTerrainPlus {
	/**
	 * @brief GPGPU compute suites for Super Terrain + program, powered by CUDA
	*/
	namespace STPCompute {
		
		/**
		 * @brief Generate the terriain height map, the height map will be then used to
		 * represent the offset in y direction of the terrain. Heightfield is generated by 2D simplex noise.
		*/
		class STPHeightfieldGenerator {
		public:

			//STPGeneratorOperation controls the operations to perform during heightfield generation
			typedef unsigned short STPGeneratorOperation;

			//TODO You can change your preferred RNG here!
			//Choosen generator for curand
			typedef curandStatePhilox4_32_10 curandRNG;

			//Store chunk image that needs to be loaded into rendering buffer, and their respective local chunk ID
			typedef std::list<std::pair<unsigned short*, unsigned int>> STPRenderingImage;

			//A function that converts biome id to the index corresponded in biome table
			//By default it's a 1-1 mapping, meaning biome id = index
			typedef size_t(*STPBiomeInterpreter)(STPBiome::Sample);

			//Generate a new heightmap with simplex noise and store the result in the provided memory space
			constexpr static STPGeneratorOperation HeightmapGeneration = 1u << 0u;
			//Erode the heightmap. If HeightmapGeneration flag is not enabled, an available heightmap needs to be provided for the operation
			constexpr static STPGeneratorOperation Erosion = 1u << 1u;
			//Generate normal map and integrate into heightfield. If HeightmapGeneration flag is not enabled, an available heightmap needs to be provided for the operation
			//RGB channel will then contain normalmap and A channel contains heightmap
			//Then format the heightfield map from FP32 to INT16.
			constexpr static STPGeneratorOperation RenderingBufferGeneration = 1u << 2u;

			/**
			 * @brief STPMapStorage stores heightfield data for the generator
			*/
			struct STPMapStorage {
			public:

				//- A float array that will be used to stored heightmap pixles, must be pre-allocated with at least width * height * sizeof(float), i.e., R32F format
				//- If generator is instructed to generate only a single heightmap, only one map is required
				//- If hydraulic erosion and/or normalmap generation is enabled, a list of maps of neighbour chunks are required for edge sync, heightmap generation will 
				//only affect the central chunk, for neighbour chunks it must be precomputed with heightmap to be able to perform free-slip hydraulic erosion,
				//If free-slip hydraulic erosion is disabled, no neighbour chunks are required.
				//- The map pointers should be arranged in row major matrix, with defined neighbour dimension.
				std::list<float*> Heightmap32F;
				//The x vector specify the offset on x direction of the map and and z on y direction of the map, and the y vector specify the offset on the final result.
				//The offset parameter will only be applied on the heightmap generation.
				float3 HeightmapOffset = make_float3(0.0f, 0.0f, 0.0f);
				//A INT16 array that will be used to stored the heightmap and normalmap after formation. The final format will become RGBA.
				//The number of pointer provided should be the same as the number of heightmap and normalmap.
				std::list<unsigned short*> Heightfield16UI;

			};

		private:

			/**
			 * @brief Memory allocation for pinned memory
			*/
			class STPHeightfieldHostAllocator {
			public:

				/**
				 * @brief Allocate page-locked memory on host
				 * @param count The number of byte to allocate
				 * @return The memory pointer
				*/
				__host__ void* allocate(size_t);

				/**
				 * @brief Free up the host pinned memory
				 * @param count The size to free
				 * @param The host pinned pointer to free
				*/
				__host__ void deallocate(size_t, void*);

			};

			/**
			 * @brief CUDA nonblocking stream allocator
			*/
			class STPHeightfieldNonblockingStreamAllocator {
			public:

				/**
				 * @brief Allocate nonblocking stream
				 * @param count Useless argument, it will only allocate one stream at a time
				 * @return The pointer to stream
				*/
				__host__ void* allocate(size_t);

				/**
				 * @brief Destroy the stream
				 * @param count Useless argument, it will only destroy one stream
				 * @param The stream to destroy
				*/
				__host__ void deallocate(size_t, void*);
			};

			//Launch parameter for texture
			dim3 numThreadperBlock_Map, numBlock_Map, numBlock_FreeslipMap, numThreadperBlock_Rendering;
			//Launch parameter for hydraulic erosion and interpolation
			unsigned int numThreadperBlock_Erosion, numBlock_Erosion, numThreadperBlock_Interpolation, numBlock_Interpolation;
			//An array of device pointers to rendering buffer on device, managed memory
			unsigned short** RenderingBuffer;
			uint2* RenderingBufferOffset;

			/**
			 * @brief Simplex noise generator, on device
			*/
			STPSimplexNoise* simplex = nullptr;
			const STPSimplexNoise simplex_h;
			//All parameters for the noise generator, stored on host, passing value to device
			const STPSettings::STPSimplexNoiseSettings Noise_Settings;

			//curand random number generator for erosion, each generator will be dedicated for one thread, i.e., thread independency
			curandRNG* RNG_Map = nullptr;
			/**
			 * @brief Convert global index to local index, making data access outside the central chunk available
			 * As shown the difference between local and global index
			 *		 Local					 Global
			 * 0 1 2 3 | 0 1 2 3	0  1  2  3  | 4  5  6  7
			 * 4 5 6 7 | 4 5 6 7	8  9  10 11 | 12 13 14 15
			 * -----------------	-------------------------
			 * 0 1 2 3 | 0 1 2 3	16 17 18 19 | 20 21 22 23
			 * 4 5 6 7 | 4 5 6 7	24 25 26 27 | 28 29 30 21
			 *
			 * Given that chunk should be arranged in a linear array (just an example)
			 * Chunk 1 | Chunk 2
			 * -----------------
			 * Chunk 3 | Chunk 4
			*/
			unsigned int* GlobalLocalIndex = nullptr;
			/**
			 * @brief Convert threadID to the coordinate on heightmap on freeslip chunks that need to be interpolated such that heightmap edges are seamless.
			 * - If interpolation patch is an edge and it's aligned as a column (patch size is 2*(Chunksize.y - 2)), the coordinate points to the left and 
			 * interpolation should be done from left to right.
			 * - If interpolation patch is an edge and it's aligned as a row (patch size is (Chunksize.x - 2)*2), the coordinate points to the up and 
			 * interpolation should be done from up to down.
			 * - If interpolation patch is a corner (patch size is 2*2), the coordinate points to the upper-left and 
			 * interpolation should be done from upper-left to bottom-right, row first.
			 * - MSB of each component will be used as a flag, such that range of the value should not exceed the range of [0,2^(32)-1].
			 * - MSB.x = 1 and MSB.y = 1: corner interpolation
			 * - MSB.x = 1 and MSB.y = 0: interploation goes in x direction (left to right), it's a column edge interpolation
			 * - MSB.x = 0 and MSB.y = 1: interploation goes in y direction (up to down), it's a row edge interpolation
			 * - Any other MSB combinations will be marked as errors and program will crash for the sake of memory safety
			*/
			uint2* InterpolationIndex = nullptr;
			//Total number of thread needed for all interpolation, note that the actual number of thread launched might be more than this number
			unsigned int InterpolationThreadRequired;
			//Free slip range in the unit of chunk
			const uint2 FreeSlipChunk;
			//Determine the number of raindrop to summon, the higher the more accurate but slower
			//Each time this value changes, the rng needs to be re-sampled
			unsigned int NumRaindrop = 0u;

			STPBiome::STPBiome* BiomeDictionary = nullptr;

			//Temp cache on device for heightmap computation
			mutable std::mutex MapCachePinned_lock;
			mutable std::mutex StreamPool_lock;
			mutable cudaMemPool_t MapCacheDevice;
			mutable cudaMemPool_t RenderCacheDevice;
			mutable STPMemoryPool<void, STPHeightfieldHostAllocator> MapCachePinned;
			mutable STPMemoryPool<void, STPHeightfieldNonblockingStreamAllocator> StreamPool;

			/**
			 * @brief Initialise the local global index lookup table
			*/
			__host__ void initLocalGlobalIndexCUDA();

			/**
			 * @brief Initialise the interpolation index lookup table
			*/
			__host__ void initInterpolationIndexCUDA();

		public:

			/**
			 * @brief Init the heightfield generator
			 * @param noise_settings Stored all parameters for the heightmap random number generator, it will be deep copied to the class so dynamic memory is not required
			 * @param chunk_settings Stored all parameters for the chunk
			 * @param hint_level_of_concurrency The average numebr of thread that will be used to issue commands to this class.
			 * It's used to assume the size of memory pool to allocate.
			*/
			__host__ STPHeightfieldGenerator(const STPSettings::STPSimplexNoiseSettings*, const STPSettings::STPChunkSettings*, unsigned int);

			__host__ ~STPHeightfieldGenerator();

			__host__ STPHeightfieldGenerator(const STPHeightfieldGenerator&) = delete;

			__host__ STPHeightfieldGenerator(STPHeightfieldGenerator&&) = delete;

			__host__ STPHeightfieldGenerator& operator=(const STPHeightfieldGenerator&) = delete;

			__host__ STPHeightfieldGenerator& operator=(STPHeightfieldGenerator&&) = delete;

			/**
			 * @brief Load the settings for heightfield generator, all subsequent computation will base on this settings. Settings are copied.
			 * It needs to be called before launching any compute
			 * @param settings The parameters of the generation algorithm. It should be on host side.
			 * @return True if setting can be used
			*/
			__host__ static bool InitGenerator(const STPSettings::STPHeightfieldSettings* const);

			/**
			 * @brief Define the biome dictionary for looking up biome settins according to the biome id. Each entry of biome will be copied to device
			 * @tparam Ite The iterator to the original container with all biomes
			 * @param begin The beginning of the container with biomes
			 * @param end The end of the container with biomes
			 * @return True if copy was successful
			*/
			template<typename Ite>
			__host__ bool defineDictionary(Ite, Ite);

			/**
			 * @brief Generate the terrain heightfield maps, each heightfield contains four maps, being heightmap and normalmap.
			 * All storage spaces must be preallocated with width * height * sizeof(float), with the exception of normalmap, which requires width * height * sizeof(float) * 4.
			 * The function will first generate our epic height map using simplex noise function, using the parameter provided during class init.
			 * The generated heightmap will be in range [0,1]
			 * Then performing hydraulic erosion algorithm to erode the rough terrain into a more natrual form.
			 * The number of iteration must be set via setErosionIterationCUDA() so pre-computation can be done before launching the program.
			 * Lastly it will generate the normal map for the height map, the normalmap is normalised within the range [0,1].
			 * All four maps are kept in floating point pixel format.
			 * @param args The generator data, see STPMapStorage documentation for more details
			 * @param operation Control what type of operation generator does
			 * @return True if all operations are successful without any errors
			*/
			__host__ bool operator()(STPMapStorage&, STPGeneratorOperation) const;

			/**
			 * @brief Transfer rendering buffer on host side to device (OpenGL) rendering buffer
			 * @param buffer Rendering buffer on device side, a mapped OpenGL pointer.
			 * Rendering buffer is continuous, function will determine pointer offset and only chunk specified in the "image" argument will be updated.
			 * @param image Chunk buffer needs to be transferred, and the relative local chunk ID.
			 * Chunk ID specify which chunk in rendering buffer will be overwritten.
			 * @param rendered_chunk The number of chunk presented on the rendering buffer
			 * @return True if all operations are successfully performed
			*/
			__host__ bool renderingBufferSubDataCUDA(cudaArray_t, STPRenderingImage&, glm::uvec2) const;

			/**
			 * @brief Set the number of raindrop to spawn for each hydraulic erosion run, each time the function is called some recalculation needs to be re-done.
			 * Determine the number of raindrop to summon, the higher the more accurate but slower
			 * @param raindrop_count The number of raindrop (number ofc iteration) for the erosion algorithm
			 * @return True if successsfully updated the count and no error was generated during calculation
			*/
			__host__ bool setErosionIterationCUDA(unsigned int);

			/**
			 * @brief Get the number of iteration for hydraulic erosion
			 * @return The number of raindrop to erode the terrain
			*/
			__host__ unsigned int getErosionIteration() const;

		};

	}
}
#include "STPHeightfieldGenerator.inl"
#endif//_STP_HEIGHTFIELD_GENERATOR_CUH_