#pragma once
#ifndef _STP_FREESLIP_GENERATOR_CUH_
#define _STP_FREESLIP_GENERATOR_CUH_

#include <STPCoreDefine.h>
//System
#include <memory>
//CUDA
#include <cuda_runtime.h>
//Free-slip Data
#include "STPFreeSlipManager.cuh"

/**
 * @brief Super Terrain + is an open source, procedural terrain engine running on OpenGL 4.6, which utilises most modern terrain rendering techniques
 * including perlin noise generated height map, hydrology processing and marching cube algorithm.
 * Super Terrain + uses GLFW library for display and GLAD for opengl contexting.
*/
namespace SuperTerrainPlus {
	/**
	 * @brief GPGPU compute suites for Super Terrain + program, powered by CUDA
	*/
	namespace STPCompute {

		/**
		 * @brief STPFreeSlipGenerator provides a center chunk for erosion and some neighbour chunks that hold data access out of the center chunk.
		 * It will the convert global index to local index, such that indeices can "free slip" out of the center chunk.
		*/
		class STP_API STPFreeSlipGenerator : private STPFreeSlipData {
		public:

			/**
			 * @brief STPFreeSlipManagerType denotes the type of free-slip manager to retrieve.
			 * Once retrieved, the manager can only be used in designated memory space
			*/
			enum class STPFreeSlipManagerType : unsigned char {
				HostManager = 0x00u,
				DeviceManager = 0x01u
			};

		private:

			//Make a copy of global-local index table on host side
			std::unique_ptr<unsigned int[]> Index_Host;
			//Same for device side
			unsigned int* Index_Device;
			//Freeslip data copy on device side, the device index table is contained
			STPFreeSlipData* Data_Device;

			/**
			 * @brief Initialise the local global index lookup table
			*/
			__host__ void initLocalGlobalIndexCUDA();

			/**
			 * @brief Try to delete the device index table (if exists)
			*/
			__host__ void clearDeviceIndex() noexcept;

		public:

			/**
			 * @brief Init STPFreeSlipGenerator and generate global-local index table
			 * @param range Free slip range in the unit of chunk
			 * @param mapSize The size of the each heightmap
			*/
			__host__ STPFreeSlipGenerator(uint2, uint2);

			__host__ ~STPFreeSlipGenerator();

			__host__ STPFreeSlipGenerator(const STPFreeSlipGenerator&) = delete;

			__host__ STPFreeSlipGenerator(STPFreeSlipGenerator&&) = delete;

			__host__ STPFreeSlipGenerator& operator=(const STPFreeSlipGenerator&) = delete;

			__host__ STPFreeSlipGenerator& operator=(STPFreeSlipGenerator&&) = delete;

			/**
			 * @brief Get the dimension of each texture.
			 * @return The pointer to dimension
			*/
			__host__ const uint2& getDimension() const;

			/**
			 * @brief Get the number of free-slip chunk
			 * @return The poiner to free-slip chunk
			*/
			__host__ const uint2& getFreeSlipChunk() const;

			/**
			 * @brief Get the number of pixel in total in free-slip logic
			 * @return The pointer to the free-slip range
			*/
			__host__ const uint2& getFreeSlipRange() const;

			/**
			 * @brief Get the free-slip manager that uses index system generated by the current generator.
			 * @tparam T The memory space where the free-slip manager will be used.
			 * @param texture The texture which will be used to indexed in a free-slip manner
			 * @return The free-slip manager.
			 * Note that the manager is bounded to the current generator, meaning all underlying contents will be managed and become invalid once generator is deleted.
			*/
			template<STPFreeSlipManagerType T>
			__host__ STPFreeSlipManager getManager(float*) const;

		};

	}
}
#endif//_STP_FREESLIP_GENERATOR_CUH_