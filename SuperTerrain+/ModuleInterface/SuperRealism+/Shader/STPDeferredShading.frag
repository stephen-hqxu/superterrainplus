#version 460 core
#extension GL_ARB_bindless_texture : require
#extension GL_ARB_shading_language_include : require
//For non-uniform access to bindless texture
#extension GL_NV_gpu_shader5 : require

layout(early_fragment_tests) in;

//Input
in vec2 FragTexCoord;
//Output
layout(location = 0) out vec4 FragColor;

/* ------------------------------------------ Lighting ----------------------------------------------- */
//these macros will be defined to a valid number before compilation
#define LIGHT_SPACE_COUNT 2
#define LIGHT_SHADOW_FILTER 255

struct LightSetting{
	float Ka, Kd, Ks;
	float Shin;
	//spectrum lighting requires information to sample from the spectrum
	//this piece of information is user-defined, depending on how the spectrum is generated by the user
	float SpectrumCoord;
};

uniform vec3 LightDirection;
uniform LightSetting Lighting;

layout(bindless_sampler) uniform sampler1DArray LightSpectrum;

/* -------------------------------- Shadow ----------------------------------- */
#include </Common/STPLightSpaceInformation.glsl>

layout(bindless_sampler) uniform sampler2DArrayShadow Shadowmap[1];
uniform float CascadePlaneDistance[LIGHT_SPACE_COUNT - 1];
uniform float LightFrustumFar;
uniform float MaxBias, MinBias;

/* -------------------------------------------------------------------------- */
#include </Common/STPCameraInformation.glsl>

//Geometry Buffer
layout(bindless_sampler) uniform sampler2D GBuffer[5];
#define G_ALBEDO GBuffer[0]
#define G_NORMAL GBuffer[1]
#define G_SPECULAR GBuffer[2]
#define G_AO GBuffer[3]
#define G_DEPTH GBuffer[4]

//Recover fragment world position from depth buffer
vec3 depthReconstruction();
//Calculate light color for the current fragment position
vec3 calcCasterLight(vec3, vec3, float, float);
//input normal must be normalised
//This function returns the light intensity multiplier in the range [0.0, 1.0], with 0.0 means no light and 1.0 means full light.
float sampleShadow(vec3, vec3, vec3);

void main(){
	const vec3 position_world = depthReconstruction(),
		normal_world = normalize(texture(G_NORMAL, FragTexCoord).rgb);
	//get material data from the G-buffer
	const vec3 Albedo = texture(G_ALBEDO, FragTexCoord).rgb;
	const float Specular = texture(G_SPECULAR, FragTexCoord).r,
		Ambient = texture(G_AO, FragTexCoord).r;

	//lighting pass
	const vec3 LightColor = calcCasterLight(position_world, normal_world, Specular, Ambient);
	
	//because the light calculation only calculates light color, 
	//we need to burn the geometry color into the final color
	FragColor = vec4(Albedo * LightColor, 1.0f);
}

vec3 depthReconstruction(){
	//depth has range [0, 1]
	const float Depth = texture(G_DEPTH, FragTexCoord).r;
	//OpenGL requires NDC to be in range [-1, 1], so we need to convert the range
	//Note that texture coordinate is also a [0, 1] range.
	const vec4 position_clip = vec4(vec3(FragTexCoord, Depth) * 2.0f - 1.0f, 1.0f),
		position_world = Camera.InvProjectionView * position_clip;

	return position_world.xyz / position_world.w;
}

vec3 calcCasterLight(vec3 position_world, vec3 normal, float specular_strength, float ambient_strength){
	//get light color
	//spectrum lighting, sample light color from the spectrum
	//the spectrum should define an indirect and a direct light color
	const float spec_uv = Lighting.SpectrumCoord;
	const vec3 indirect_color = texture(LightSpectrum, vec2(spec_uv, 0.0f)).rgb,
		direct_color = texture(LightSpectrum, vec2(spec_uv, 1.0f)).rgb;

	//ambient
	const float ambient = ambient_strength * Lighting.Ka;
	//diffuse
	const vec3 lightDir = normalize(LightDirection);
	const float diffuse = Lighting.Kd * max(dot(lightDir, normal), 0.0f);
	//specular
	const vec3 viewDir = normalize(Camera.Position - position_world),
		reflectDir = reflect(-lightDir, normal),
		halfwayDir = normalize(lightDir + viewDir);
	const float specular = specular_strength * Lighting.Ks * pow(max(dot(normal, halfwayDir), 0.0f), Lighting.Shin);
		
	//shadow
	//the returned value represents the light intensity multiplier
	const float light_intensity = sampleShadow(position_world, normal, lightDir);
	return indirect_color * ambient + direct_color * (diffuse + specular) * light_intensity;
}

float sampleShadow(vec3 fragworldPos, vec3 normal, vec3 lightDir) {
	//select cascade level from array shadow texture
	const vec4 fragviewPos = Camera.View * vec4(fragworldPos, 1.0f);
	const float depthValue = abs(fragviewPos.z);
	const int cascadeCount = CascadePlaneDistance.length;

	int layer = -1;
	for (int i = 0; i < cascadeCount; i++) {
		if (depthValue < CascadePlaneDistance[i]) {
			layer = i;
			break;
		}
	}
	//no layer can be determined
	if (layer == -1) {
		layer = cascadeCount;
	}

	//convert world position to light clip space
	//as we are dealing with directional light, w component is always 1.0
	const vec4 fraglightPos = LightSpace.ProjectionView[layer] * vec4(fragworldPos, 1.0f);
	//perform perspective division and transform to [0, 1] range
	const vec3 projCoord = (fraglightPos.xyz / fraglightPos.w) * 0.5f + 0.5f;

	//get depth of current fragment from light's perspective
	const float currentDepth = projCoord.z;
	if (currentDepth > 1.0f) {
		//keep the light intensity at 0.0 when outside the far plane region of the light's frustum.
		return 1.0f;
	}

	//calcualte bias based on depth map resolution and slope
	float bias = max(MaxBias * (1.0f - dot(normal, lightDir)), MinBias);
	bias /= ((layer == cascadeCount) ? LightFrustumFar : CascadePlaneDistance[layer]) * 0.5f;

	//get closest depth value from light's perspective
	//the `texture` function computes the shadow value and returns (1.0 - shadow).
#if LIGHT_SHADOW_FILTER == 2
	//Percentage-Closer Filtering

#else
	//no filter, nearest and linear filtering are done by hardware automatically
	return texture(Shadowmap[0], vec4(projCoord.xy, layer, currentDepth - bias)).r;
#endif
}